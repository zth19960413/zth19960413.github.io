<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="阿九的博客">
    <meta name="keyword" content="阿九">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        学习笔记之网络部分 - 阿九的狗窝 | Ajiu&#39;s kennel
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 人生就是不停的遇到困难，然后解决困难 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>阿 九</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI开放式互联参考模型"><span class="toc-text">OSI开放式互联参考模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP协议"><span class="toc-text">TCP/IP协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三次握手"><span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP报文头"><span class="toc-text">TCP报文头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-Flood的防护"><span class="toc-text">SYN  Flood的防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要进行三次握手"><span class="toc-text">为什么要进行三次握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四次挥手"><span class="toc-text">四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT"><span class="toc-text">TIME_WAIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要进行四次挥手"><span class="toc-text">为什么要进行四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLOSE-WAIT"><span class="toc-text">CLOSE_WAIT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#滑动窗口"><span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP和UDP的区别"><span class="toc-text">TCP和UDP的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#请求结构"><span class="toc-text">请求结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应结构"><span class="toc-text">响应结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求-响应步骤"><span class="toc-text">请求/响应步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器输入URL经历的流程"><span class="toc-text">浏览器输入URL经历的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态码"><span class="toc-text">状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET和POST的区别"><span class="toc-text">GET和POST的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie和Session的区别"><span class="toc-text">Cookie和Session的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP和HTTPS的区别"><span class="toc-text">HTTP和HTTPS的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket"><span class="toc-text">Socket</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 人生就是不停的遇到困难，然后解决困难 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        学习笔记之网络部分
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-05-28 18:00:01</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#网络" title="网络">网络</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p><strong>在进入大三阶段，马上面临大四即将到来的实习，在此时期为了能找到一个好的工作，对大学所学的知识，依据慕课网《剑指Java面试-Offer直通车》的讲解体系，进行了一个系统化的总结</strong></p>
<p><del>接下来进入第一章网络部分的讲解</del></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><hr>
<h2 id="OSI开放式互联参考模型"><a href="#OSI开放式互联参考模型" class="headerlink" title="OSI开放式互联参考模型"></a>OSI开放式互联参考模型</h2><ul>
<li><p>物理层：机械、电子、定时接口通信商的原始比特流传输，这里就是发送比特流最基本的数据，就是0101二进制数据，最根本的就是电流的强弱来进行传输，比如高电平是1低电平是0。</p>
</li>
<li><p>数据链路层：物理寻址、同时将原始比特流转变为逻辑传输线路。这里主要是对数据进行格式化，对数据进行一层封装，加了一层的校验。</p>
</li>
<li><p>网络层：控制子网的运行，如逻辑地址、分组传输、路由的选择。把网络地址翻译成对应的物理地址，我的理解就是可以寻址。给这段代码在网络上给了一个表示，目的地址和本地地址应该在这里面。</p>
</li>
<li><p>传输层：接收上一层的数据，在必要的时候吧数据进行分割，并将这些数据交给网络层，且保证这些数据段有效到达对端。这一层主要考虑的是传输质量的问题，对于接收方能接受的数据的程度来对数据进行处理。对数据包可以进行强制分割，以至于在传输的过程中不会造成大量丢失，使网络传输的接受范围之内。</p>
</li>
<li><p>会话层：不同机器上的据用之间建立和管理回话。</p>
</li>
<li><p>表示层：信息的语法语义以及它们的关联，如加密解密、转换翻译、压缩解压缩。主要一个功能就是解决不同系统之间的通信，比如我是windows和一个linux系统的之间通信就是靠表示层来进行转换翻译和解压缩的。</p>
</li>
<li><p>应用层：这里比较关注的就是HTTP协议</p>
</li>
</ul>
<blockquote>
<p><strong>OSI并不是一个标准，而是一个在制定标准时所使用的概念性框架。</strong></p>
</blockquote>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190528201225.png" alt="先自上而下，后自下而上处理数据头部"></p>
<h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190528201302.png" alt="OSI的“实现”：TCP/IP"></p>
<p><strong>传输控制协议TCP简介</strong></p>
<ol>
<li><p>面向连接的、可靠的、基于字节流的传输层通信协议</p>
</li>
<li><p>将应用层的数据流分割成报文段并发送给目标节点的TCP层</p>
</li>
<li><p>数据包都有序号，对方收到则发送ACK确认，未收到则重新传</p>
</li>
<li><p>使用校验和来检验数据在传输过程中是否有误  TCP Flags</p>
</li>
</ol>
<p><strong>TCP Flags</strong></p>
<ul>
<li><p>URG：紧急指针标志</p>
</li>
<li><p><strong>ACK：确认序号标志（1表示确认号有效，0报文中不含确认信息）</strong></p>
</li>
<li><p>PSH：push标志（相当于优先处理，不在缓冲区排队）</p>
</li>
<li><p>RST：重置连接标志</p>
</li>
<li><p><strong>SYN：同步序号，用于建立连接过程 </strong></p>
</li>
<li><p><strong>FIN：finish标志用于释放连接（1没有数据发送了，0还有数据）</strong></p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2></li>
</ul>
<blockquote>
<p><strong>TCP是全双工的通信，三次握手是为了建立连接</strong></p>
</blockquote>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190528201519.png" alt=" 流程图 "></p>
<p>Seq（Sequence Number）是初始信号正整数值</p>
<p>在第一次握手接收端返回的ack为x+1，因为在之前seq消耗了一个x就要+1，seq是为缓存初始一个序列号y</p>
<p>同理在第三次握手的时候发送端的seq为x+1，ack为y+1</p>
<p><strong>在TCP/IP协议中，TCP协议提供可靠的链接服务，采用三次握手建立一个链接</strong></p>
<blockquote>
<p><strong>第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；</strong></p>
</blockquote>
<blockquote>
<p><strong>第二次握手：服务器收到SYN包，必须确认客户的SYN（ackj+1），同时自己也发送一个SYN包（syn=k）,即SYN+ACK包，此时服务器进入SYN_RECV状态；</strong></p>
</blockquote>
<blockquote>
<p><strong>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，进行数据的传输。</strong></p>
</blockquote>
<h3 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h3><p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190528202707.png" alt="TCP报文头"></p>
<p>这里我对TCP的报文头不做过多的说明，在网上有好多博客写了这方面的知识比较全面</p>
<p>如果对这里特别感兴趣可以下载Wireshark的抓包工具。</p>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190528203306.png" alt="Wireshark"></p>
<p>我打开这个软件，随便浏览网上一个网址，在上面地址栏输入正则表达式，然后对一个固定IP36.104.142.35进行抓包，就可以查看TCP的链接状态，以及报文内容格式</p>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190528203756.png" alt="抓包截图"></p>
<h3 id="SYN-Flood的防护"><a href="#SYN-Flood的防护" class="headerlink" title="SYN  Flood的防护"></a>SYN  Flood的防护</h3><p><strong>在第一次握手的时候会有超时的隐患</strong></p>
<p><strong>问题起因的分析</strong></p>
<ul>
<li><p>Server（服务器端）收到Clinent（客户端）的SYN，恢复SYN-ACK的时候，我们的Clinent就掉线了，Server未收到ACK的确认，那么这个连接就会处于一个中间的状态，即没有成功也没有失败</p>
</li>
<li><p>Server（服务器端）不断重连直至超时，Linux默认重试次数为5次，每次重连的时间从1秒开始，每次都翻倍，一共的等待1+2+4+6+16+32=63秒（这里可以理解为一个加号为一次重连机会）才断开连接</p>
</li>
</ul>
<p><strong>在这个时候有可能会遭受到SYN Flood攻击的风险，攻击程序会给服务器发送一个SYN的报文，发了之后它就下线了需要服务器默认等63秒才会断开这个连接，这样攻击者就会把服务器的SYN连接的队列耗尽，将正常的连接请求不能处理。</strong></p>
<p><strong>针对SYN Flood的防护措施</strong></p>
<ul>
<li><p>在Linux下呢，SYN队列满了后，通过源地址端口和目标地址端口和时间戳打造出特别的seq就是tcp_syncookies参数回发SYN Cookie，如果是攻击者是不会有响应的</p>
</li>
<li><p>若为正常连接则Clinet会回发SYN Cookie，利用Cookie来直接建立连接。</p>
</li>
</ul>
<p><strong>建立连接后，Client出现了故障怎么办</strong></p>
<p>TCP还设有保活机制</p>
<ul>
<li><p>在一段时间，连接处于非活动状态，开启保护功能的一段向对方发送保活探测报文，如果发送端没有收到响应报文，那么经过体检经过设置好的保活时间内则继续发送知道连接为止</p>
</li>
<li><p>尝试次数达到保活探测数仍未收到响应则中断连接</p>
</li>
</ul>
<h3 id="为什么要进行三次握手"><a href="#为什么要进行三次握手" class="headerlink" title="为什么要进行三次握手"></a>为什么要进行三次握手</h3><p><strong>为了初始化Sequence Number的初始值，通信的双方通知自己的初始化的SN的值，作为以后通信的信号，不会因为网络上的传输问题而乱序，TCP用这个序号来拼接这个序号。</strong></p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190528211446.png" alt="流程图"></p>
<p>TCP采用四次挥手来释放连接</p>
<blockquote>
<p><strong>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；</strong></p>
</blockquote>
<blockquote>
<p><strong>第二次挥手：server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态；</strong></p>
</blockquote>
<blockquote>
<p><strong>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；</strong></p>
</blockquote>
<blockquote>
<p><strong>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</strong></p>
</blockquote>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p><strong>为什么会有TIME_WAIT的状态？</strong></p>
<ul>
<li><p>确保有足够的时间让对端收到ACK的包，如果被动关闭的一方没有收到ACK，就会触发被动端重发Finish。</p>
</li>
<li><p>有足够的时间，让连接不会跟后面的链接混在一起，因为有些路由器会缓存IP数据包，如果连接被重用了那么这些延迟收到的包呢，就有可能会跟新连接的包混在一起。</p>
</li>
</ul>
<h3 id="为什么要进行四次挥手"><a href="#为什么要进行四次挥手" class="headerlink" title="为什么要进行四次挥手"></a>为什么要进行四次挥手</h3><p>因为是全双工的，发送方和接收方都需要FIN报文和ACK报文。其实只需要两次挥手即可，只不过有一方是被动的所以看上去就成了所谓的四次挥手</p>
<h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h3><p>服务器出现大量CLOSE_WAIT状态的原因</p>
<p>对方关闭socket连接，我方忙于读或者写，没有及时的关闭连接，遇到这种情况多数是程序有BUG，还有可能是线程的配置不合理。</p>
<p>解决方法</p>
<ul>
<li><p>检查代码</p>
</li>
<li><p>检查配置</p>
</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><strong>首先了解RTT和RTO是什么</strong></p>
<ul>
<li><p>RTT：发送一个数据包到收到对应的ADC，所花费的时间</p>
</li>
<li><p>RTO：重传时间间隔</p>
</li>
</ul>
<p><strong>前面我们了解到TCP会将数据拆分成段进行发送，出于效率和传输速度的考虑，我们不可能等一段数据去发送，等到上一段数据被确认之后再发送下一段数据，这个效率是非常低的，我们是要实现对数据的批量发送，TCP必须要解决可靠传输以及包乱序的问题，所以TCP需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</strong></p>
<p>TCP使用滑动窗口做流量控制与乱序重排，两个作用</p>
<ul>
<li><p>保证TCP的可靠性</p>
</li>
<li><p>保证TCP的流控特性</p>
</li>
</ul>
<p><strong>前面在TCP的报文头中有一个字段是WINDOWS，就是第四行第二的字段就是滑动窗口的字段。用于接收方通知发送方自己，还有多少缓冲区可以接收数据，发送方根据接收方的处理能力来发送数据。不会导致接收方处理不过来，这就是流量控制。</strong></p>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529162421.png" alt="滑动窗口"></p>
<p>根据上面的图可以清晰的理解到底什么是滑动窗口</p>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529162540.png" alt="UDP报文"></p>
<p>上图是UDP报文的结构，相对于TCP少了很多。</p>
<p><strong>UDP的特点：</strong></p>
<ul>
<li><p>面向非连接，传送速度是根据程序生成的速度所影响。</p>
</li>
<li><p>不维护连接状态，服务端支持同时向多个客户端传输相同的消息</p>
</li>
<li><p>数据包报头只有8个字节，额外开销小</p>
</li>
<li><p>吞吐量只受限于数据生成速率、传输速率以及机器性能</p>
</li>
<li><p>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表。</p>
</li>
<li><p>面向报文，不对应用程序提交的报文信息进行拆分或者合并</p>
</li>
</ul>
<p><strong>TCP和UDP的区别结论</strong></p>
<ul>
<li><p>面向连接 VS 无连接</p>
</li>
<li><p>TCP是可靠的</p>
</li>
<li><p>TCP是有序的</p>
</li>
<li><p>TCP的速度比UDP的速度慢</p>
</li>
<li><p>UDP是轻量级的</p>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>超文本传输协议HTTP主要特点：</strong></p>
<ul>
<li><p>支持客户/服务器模式</p>
</li>
<li><p>简单快速（只需要传送请求方法和路径，get和post）</p>
</li>
<li><p>灵活（传输任意类型的数据对象）</p>
</li>
<li><p>无连接 </p>
</li>
<li><p>无状态（对于事务的处理没有记忆能力）</p>
</li>
</ul>
<h2 id="请求结构"><a href="#请求结构" class="headerlink" title="请求结构"></a>请求结构</h2><p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529163317.png" alt="HTTP的请求结构"></p>
<h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529163451.png" alt="HTTP的响应结构"></p>
<h2 id="请求-响应步骤"><a href="#请求-响应步骤" class="headerlink" title="请求/响应步骤"></a>请求/响应步骤</h2><ol>
<li><p>客户端连接到Web服务器</p>
</li>
<li><p>发送HTTP请求</p>
</li>
<li><p>服务器接收请求并返回HTTP响应</p>
</li>
<li><p>释放连接TCP连接</p>
</li>
<li><p>客户端浏览器解析HTML内容</p>
</li>
</ol>
<h2 id="浏览器输入URL经历的流程"><a href="#浏览器输入URL经历的流程" class="headerlink" title="浏览器输入URL经历的流程"></a>浏览器输入URL经历的流程</h2><ol>
<li><p>DNS解析，先接续本地，然后路由器，然后上级域名，然后顶级域名这样如果查到了不再继续向上查询。</p>
</li>
<li><p>TCP连接</p>
</li>
<li><p>发送HTTP请求</p>
</li>
<li><p>服务器处理请求并返回HTTP报文</p>
</li>
<li><p>浏览器解析渲染页面，就是所谓的加载界面</p>
</li>
<li><p>连接结束</p>
</li>
</ol>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><strong>这里的状态码由于太多了，我进行了一个归类根据第一个数字进行归类如下</strong></p>
<ul>
<li><p>1XX：指示信息–表示请求已经接受，继续处理</p>
</li>
<li><p>2XX：成功–表示请求已被成功接受、理解、接受</p>
</li>
<li><p>3XX：重定向–要完成请求必须进行跟进一步的操作</p>
</li>
<li><p>4XX：客户端错误–请求有语法错误或请求无法实现</p>
</li>
<li><p>5XX：服务器端错误–服务器未能实现合法的请求</p>
</li>
</ul>
<p><strong>根据我所遇到的有如下经常看到的进行了总结</strong></p>
<ul>
<li><p>200 OK：正常返回信息</p>
</li>
<li><p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</p>
</li>
<li><p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p>
</li>
<li><p>403 Forbidden：服务器收到请求，但是拒绝提供服务</p>
</li>
<li><p>404 Not Found：请求资源不存在或者输入了错误的URL</p>
</li>
<li><p>500 Internal Server Error：服务器发生不可预期的错误</p>
</li>
<li><p>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</li>
</ul>
<h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p><strong>从三个层面来解答</strong></p>
<ul>
<li><p>从Http报文的层面上来说，get请求的信息可以放在URL中，有些浏览器对于URL对于长度有限制，那么get的请求可能会丢失信息。对于大量的来说只能用POST</p>
</li>
<li><p>从数据库的层面上来说，get请求是对数据库进行了操作，操作和结果是一致的，具有幂等性。对数据库的操作，但是没有改变数据库中的数据，get请求是做查询操作，所以不会改变数据库，所以也具有安全性 。</p>
</li>
<li><p>其他层面：GET可以被缓存，可以存在浏览器的缓存中</p>
<h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2></li>
</ul>
<p><strong>Cookie</strong></p>
<p>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</p>
<p>客户端再次请求的时候，会把Cookie回发</p>
<p>服务器接收到后，会解析Cookie生成与客户端相对应的内容  </p>
<p><strong>Cookie的设置以及发送过程</strong></p>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529165109.png" alt="Cookie的设置以及发送过程"></p>
<p><strong>Session</strong></p>
<p>服务器的机制，在服务器上保存的信息</p>
<p>解析客户端请求并操作session id，按需要保存状态信息</p>
<p>Session实现方式有两种：</p>
<ul>
<li>用Cookie来实现</li>
</ul>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529165237.png" alt></p>
<ul>
<li>使用URL回写来实现   </li>
</ul>
<p><strong>它们之间的区别</strong></p>
<ul>
<li><p>Cookie数据存放在客户的浏览器上，Session数据放在服务器上</p>
</li>
<li><p>Session相对于Cookie更安全</p>
</li>
<li><p>若考虑减轻服务器的负担，应当使用Cooke</p>
</li>
</ul>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529165428.png" alt="HTTP和HTTPS的区别"></p>
<p>图中的SLL（Security Sockets Layer，安全套接层）</p>
<ul>
<li><p>为网络通信提供安全及数据完整性的一种安全协议</p>
</li>
<li><p>是操作系统对外的API，SSL3.0后更名为TLS</p>
</li>
<li><p>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p>
</li>
</ul>
<p>HTTPS数据传输流程</p>
<ul>
<li><p>浏览器将支持的加密算法信息发送给服务器</p>
</li>
<li><p>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</p>
</li>
<li><p>浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器</p>
</li>
<li><p>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</p>
</li>
<li><p>浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据</p>
</li>
</ul>
<p><strong>它们根本的区别</strong></p>
<ul>
<li><p>HTTPS需要到CA申请证书，HTTP不需要</p>
</li>
<li><p>HTTPS密文传输，HTTP明文传输</p>
</li>
<li><p>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</p>
</li>
<li><p>HTTPS=HTTP+加密</p>
</li>
</ul>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口</p>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529205902.png" alt></p>
<p><strong>Socket是基于一种从打开到读和写再到关闭的这种模式去实现的，服务器和客户端各自维护一个文件再建立连接打开后，可以向自己文件写入内容供对方读取，或者读取对方内容，再通信结束时，就会关闭文件。</strong></p>
<p><img src="http://prj1hj366.bkt.clouddn.com/qiniu_picGO/20190529210227.png" alt="Socket通信流程"></p>
<p>##关于SOCKET的一道面试题</p>
<p><strong>编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命令行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度，分别用TCP和UDP两种方法去实现</strong></p>
<p><strong>TCP实现具体代码如下</strong></p>
<p><strong>TCP Server(服务器)</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.net.ServerSocket;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.net.Socket;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws Exception&#123;</span><br><span class="line">        <span class="comment">// 创建socket，并将socket绑定到65000端口</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">65000</span>);</span><br><span class="line">        <span class="comment">// 死循环，使得socket一直等待并处理客户端发送过来的请求</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 监听65000端口，知道客户端返回连接信息才返回</span></span><br><span class="line">            Socket socket = ss.accept();</span><br><span class="line">            <span class="comment">// 获取客户端的请求信息后，执行相关业务逻辑</span></span><br><span class="line">            <span class="keyword">new</span> LengthCalculator(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LengthCalculator</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> class LengthCalculator extends Thread&#123;</span><br><span class="line">    <span class="comment">// 以socket为成员变量</span></span><br><span class="line">    <span class="keyword">private</span> final Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LengthCalculator(Socket socket) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取socket的输出流</span></span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">// 获取socket的输入流</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度</span></span><br><span class="line">            ch = is.<span class="built_in">read</span>(buff);</span><br><span class="line">            <span class="comment">// 将接收流的byte数组转换成字符串，这里获取的内容是客户端发过来的字符串参数</span></span><br><span class="line">            <span class="keyword">String</span> content = <span class="keyword">new</span> <span class="keyword">String</span>(buff,<span class="number">0</span>,ch);</span><br><span class="line">            System.err.<span class="built_in">println</span>(content);</span><br><span class="line">            <span class="comment">// 往输出流里写入获得的字符串的长度，并回发给客户端</span></span><br><span class="line">            os.<span class="built_in">write</span>(<span class="keyword">String</span>.valueOf(content.length()).getBytes());</span><br><span class="line">            <span class="comment">// 这里不要忘了关闭输入输出流的socket</span></span><br><span class="line">            os.<span class="built_in">close</span>();</span><br><span class="line">            is.<span class="built_in">close</span>();</span><br><span class="line">            socket.<span class="built_in">close</span>();</span><br><span class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TCP Client(客户端)</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.util.xml.impl.Input;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> class TCPClient</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)throws Exception&#123;</span><br><span class="line">        <span class="comment">// 创建socket，并制定连接的是本机的端口号为65000 的服务器socket</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"10.1.149.66"</span>,<span class="number">65000</span>);</span><br><span class="line">        <span class="comment">// 获取输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 获取输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流当中</span></span><br><span class="line">        os.<span class="built_in">write</span>(<span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello world"</span>).getBytes());</span><br><span class="line">        <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度</span></span><br><span class="line">        ch = is.<span class="built_in">read</span>(buff);</span><br><span class="line">        <span class="comment">// 将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度</span></span><br><span class="line">        <span class="keyword">String</span> content= <span class="keyword">new</span> <span class="keyword">String</span>(buff,<span class="number">0</span>,ch);</span><br><span class="line">        System.out.<span class="built_in">println</span>(content);</span><br><span class="line">        <span class="comment">// 这里不要忘了关闭输入输出流的socket</span></span><br><span class="line">        is.<span class="built_in">close</span>();</span><br><span class="line">        os.<span class="built_in">close</span>();</span><br><span class="line">        socket.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UDP</strong></p>
<p><strong>UDP Server</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class UDPServer &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)<span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            <span class="comment">// 服务端接收客户端发送的数据包</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">65001</span>);<span class="comment">//监听端口号</span></span><br><span class="line">            <span class="comment">// 存储从客户端接收到的内容</span></span><br><span class="line">            <span class="built_in">byte</span> [] buff= <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">100</span>];</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buff,buff.length);</span><br><span class="line">            <span class="comment">// 接收客户端发过来的内容，并将内容封装进DatagramPacket对象中</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            <span class="comment">// 从DatagramPacket对象中获取到真正存储的数据</span></span><br><span class="line">            <span class="built_in">byte</span>[] data = packet.getData();</span><br><span class="line">            <span class="comment">// 将数据从二进制转换成字符串形式</span></span><br><span class="line">            <span class="keyword">String</span> content = <span class="keyword">new</span> <span class="keyword">String</span>(data,<span class="number">0</span>,packet.getLength());</span><br><span class="line">            System.err.<span class="built_in">println</span>(content);</span><br><span class="line">            <span class="comment">// 将要发送给客户端的数据转换成二进制</span></span><br><span class="line">            <span class="built_in">byte</span>[] sendedContent = <span class="keyword">String</span>.valueOf(content.length()).getBytes();</span><br><span class="line">            <span class="comment">// 服务端给客户端发送数据报</span></span><br><span class="line">            <span class="comment">// 从DatagramPacket对象中获取到数据的来源地址与端口号</span></span><br><span class="line">            DatagramPacket packetToclient = <span class="keyword">new</span> DatagramPacket(sendedContent,</span><br><span class="line">                    sendedContent.length,packet.getAddress(),packet.getPort());</span><br><span class="line">            socket.send(packetToclient);  <span class="comment">// 发送数据给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UDP Client</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception&#123;</span><br><span class="line">        <span class="comment">// 客户端发数据报给服务端</span></span><br><span class="line">        DatagramSocket socket =<span class="keyword">new</span> <span class="type">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 要发给服务端的数据</span></span><br><span class="line">        byte[] buf = <span class="string">"Hello World"</span>.getBytes();</span><br><span class="line">        <span class="comment">// 将IP地址封装成InetAddress对象</span></span><br><span class="line">        InetAddress address = InetAddress.getByName(<span class="string">"10.1.149.66"</span>);</span><br><span class="line">        <span class="comment">// 将要发送给服务端的数据封装成DatagramPacket对象，需要填写上IP地址与端口号</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> <span class="type">DatagramPacket</span>(buf, buf.length, address, <span class="number">65001</span>);</span><br><span class="line">        <span class="comment">//发送数据给服务端</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端接收服务端发过来的数据报</span></span><br><span class="line">        byte[] data = <span class="keyword">new</span> <span class="type">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">// 创建DatagramPacket对象用来存储服务端发过来的数据</span></span><br><span class="line">        DatagramPacket receivedPacket = <span class="keyword">new</span> <span class="type">DatagramPacket</span>(data,data.length);</span><br><span class="line">        <span class="comment">// 将接收到的数据存储到DatagramPacket对象中</span></span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        <span class="comment">// 将服务器端发送过来的数据取出来并打印到控制台</span></span><br><span class="line">        <span class="keyword">String</span> content = <span class="keyword">new</span> <span class="type">String</span>(receivedPacket.getData(),<span class="number">0</span>,receivedPacket.getLength());</span><br><span class="line">        System.err.println(content);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小伙伴们想知道最后的结果自己亲身动手打一下代码就知道其中的原理喽。</p>
</blockquote>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src data-src="/img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank" href="https://github.com/zth19960413">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.sunning123.top">BaoZhaTou&#39;s Page</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://airclouds-blog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>
